## 1、多线程事务

前置准备

* AnimalService的实现类

```java
@Service
@Slf4j
public class AnimalServiceImpl extends ServiceImpl<AnimalMapper, Animal> implements AnimalService {

    @Override
    public void threadRollBackFailed02(int i) {
        Animal hospital = new Animal();
        hospital.setName("测试" + UUID.randomUUID());
        save(hospital);
        if (i == 3) {
            int a = 1/0;
        }
    }

    @Autowired
    private AnimalMapper animalMapper;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void save4Tc(int i) {
        Animal animal = new Animal();
        animal.setName(UUID.randomUUID().toString());
        animalMapper.insert(animal);
        if (i == 3) {
            int a = 1/0;
        }
    }

}
```

* PersonService的实现类

```java
@Service
@Slf4j
public class PersonServiceImpl extends ServiceImpl<PersonMapper, Person> implements PersonService {
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Boolean threadRollBackFailed01(int i, String name) throws InterruptedException {
        Person school = new Person().setName(UUID.randomUUID().toString());
        if (name != null) {
            school.setName(name);
        }
        save(school);
        if (i == 3) {
            Thread.sleep(1000);
            int a = 1/0;
        }
        return true;
    }
   
}
```





### 1.1 回滚失败

#### 1.1.1  情况一

```java
@Service
@Slf4j
public class MultiThreadTcService {
 	@Autowired
    private PersonService personService;    
    @Autowired
    private AnimalService animalService;   
    
    /**
     * 多线程回滚失败情况一
     * 原因：每个子线程都是一个独立的事务，其中一个子线程异常回滚，
     *      不会影响其他子线程和主线程。
     */
    public void threadRollBackFailed01() {
        try {
            CountDownLatch downLatch = new CountDownLatch(5);
            Boolean main = personService.threadRollBackFailed01(1, "main");
            for (int i = 0; i < 5; i++) {
                int finalI = i;
                new Thread(() -> {
                    try {
                        personService.threadRollBackFailed01(finalI, null);
                    }  catch (Exception e) {
                        // 子线程抛出异常，父线程接收不到的
                        log.info("子线程{}异常", Thread.currentThread().getName());
                        throw new ServiceException(e);
                    } finally {
                        downLatch.countDown();
                    }
                }).start();
            }
            downLatch.await();
            log.info("=============end===============");
        } catch (Exception e) {
            // 子线程抛出异常，父线程接收不到的
            log.info("=============main error===============");
            e.printStackTrace();
        }
    }
    
}
```

分析：回滚失败是因为每个子线程都是一个独立的事务，其中一个子线程异常回滚，不会影响其他子线程和主线程。



#### 1.1.2  情况二

```java
@Service
@Slf4j
public class MultiThreadTcService {
 	@Autowired
    private PersonService personService;    
    @Autowired
    private AnimalService animalService;   
    
    @Transactional(rollbackFor = Exception.class)
    public Boolean threadRollBackFailed02() throws InterruptedException {
        AtomicBoolean errorFlag = new AtomicBoolean(false);
        Person Person = new Person().setName("main-" + UUID.randomUUID());
        personService.save(Person);
        CountDownLatch downLatch = new CountDownLatch(5);
        for (int i = 0; i < 5; i++) {
            int finalI = i;
            new Thread(() -> {
                try {
                    boolean error = errorFlag.get();
                    if (error) {
                        return;
                    }
                    /**
                     * 这里用声明式事务.
                     * 1、如果有一个线程出错，其他线程还没有执行完上面的代码，就不会往下执行了。
                     * 2、如果有一个线程出错，有些线程执行完上面的代码，发现没有异常，就会往下执行，这时候也不会回滚。
                     *    即只有出错的线程会回滚，其他正常执行的线程（除主线程外），是会提交事务的。
                     * 3、所有的子线程执行成功，如果主线程执行失败，这些子线程也不会回滚
                     */
                    // 业务逻辑
                    animalService.threadRollBackFailed02(finalI);
                }  catch (Exception e) {
                    errorFlag.compareAndSet(false, true);
                    log.info("子线程{}异常", Thread.currentThread().getName());
                } finally {
                    downLatch.countDown();
                }
            }).start();
        }

        // 主线程阻塞
        downLatch.await();
        boolean error = errorFlag.get();
        if (error) {
            log.info("存在子线程执行异常;主线程{}回滚", Thread.currentThread().getName());
            // 抛出异常让事务回滚
            throw new ServiceException("batch tc error");
        }
        return Boolean.TRUE;
    }
}
```





#### 1.1.3  情况三

```java
@Service
@Slf4j
public class MultiThreadTcService {
 	@Autowired
    private PersonService personService;    
    @Autowired
    private AnimalService animalService;   
    
     @Autowired
    private PlatformTransactionManager platformTransactionManager;

    @Autowired
    private TransactionDefinition transactionDefinition;


    /**
     * 多线程事务回滚情况三
     */
    @Transactional(rollbackFor = Exception.class)
    public Boolean threadRollBackFailed03() {
        // 使用线程安全的list，保存每个线程的事务属性
        List<TransactionStatus> threadTransactionStatus = new CopyOnWriteArrayList<>();
        try {
            Person person = new Person().setName("main-" + UUID.randomUUID());
            personService.save(person);
            CountDownLatch downLatch = new CountDownLatch(5);

            // 异常引用
            AtomicReference<Exception> otherThreadExceptionRef = new AtomicReference<>();
            for (int i = 0; i < 5; i++) {
                int finalI = i;
                new Thread(() -> {
                    try {
                        Exception exception = otherThreadExceptionRef.get();
                        if (exception != null) {
                            // 前面已经有线程报错了，不用执行业务逻辑了
                            return;
                        }

                        // 不在子线程提交事务。因为主线程出错了，子线程感知不到
                        // 手动开启事务
                        TransactionStatus transactionStatus = platformTransactionManager.getTransaction(transactionDefinition);
                        threadTransactionStatus.add(transactionStatus);
                        // 业务逻辑
                        animalService.save(new Animal().setName(UUID.randomUUID().toString()));
                        // 模拟异常
                        if (finalI == 3) {
                            int a = 1/0;
                        }
                    }  catch (Exception e) {
                        // 暴露异常引用
                        otherThreadExceptionRef.set(e);
                        log.info("子线程{}异常", Thread.currentThread().getName());
                    } finally {
                        downLatch.countDown();
                    }
                }).start();
            }

            // 主线程阻塞
            downLatch.await();

            Exception exception = otherThreadExceptionRef.get();
            if (exception != null) {
                // 抛出子线程异常
                throw exception;
            }
            // 提交其他线程
            commitOtherThreadTc(threadTransactionStatus);
        } catch (Exception e) {
            // 回滚其他线程
            rollBackOtherThreadTc(threadTransactionStatus);
            // 抛出异常让主事务回滚
            throw new ServiceException("batch tc error");
        }
        return Boolean.TRUE;
    }

    private void rollBackOtherThreadTc(List<TransactionStatus> threadTransactionStatus) {
        for (TransactionStatus transactionStatus : threadTransactionStatus) {
            // 手动回滚事务
            platformTransactionManager.rollback(transactionStatus);
        }
    }


    private void commitOtherThreadTc(List<TransactionStatus> threadTransactionStatus) {
        for (TransactionStatus transactionStatus : threadTransactionStatus) {
            // 手动回滚事务
            platformTransactionManager.commit(transactionStatus);
        }
    }
    
}
```



分析：

回滚失败，执行代码会发现抛出一下异常

```java
java.lang.IllegalStateException: No value for key [{
	CreateTime:"2024-04-09 21:01:44",
	ActiveCount:5,
	PoolingCount:1,
	CreateCount:6,
	DestroyCount:0,
	CloseCount:1,
	ConnectCount:6,
	Connections:[
		{ID:1743224658, ConnectTime:"2024-04-09 21:01:49", UseCount:1, LastActiveTime:"2024-04-09 21:01:49"}
	]
}] bound to thread
```





为什么会抛出以上的异常呢？在rollback方法中debug来到unbindResource处，见以下分析

```java
public class DataSourceTransactionManager extends AbstractPlatformTransactionManager
		implements ResourceTransactionManager, InitializingBean {
	@Override
	protected void doCleanupAfterCompletion(Object transaction) {
		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;

		// Remove the connection holder from the thread, if exposed.
		if (txObject.isNewConnectionHolder()) {
             // 获取数据源，释放资源
			TransactionSynchronizationManager.unbindResource(obtainDataSource());
		}
        
        ........  
    }
    
     /**
	 * Obtain the DataSource for actual use.
	 * @return the DataSource (never {@code null})
	 * @throws IllegalStateException in case of no DataSource set
	 * @since 5.0
	 */
	protected DataSource obtainDataSource() {
		DataSource dataSource = getDataSource();
		Assert.state(dataSource != null, "No DataSource set");
		return dataSource;
	}
}
```

释放资源

```java
public abstract class TransactionSynchronizationManager {
 //保存当前事务关联的资源--默认只会在新建事务的时候保存当前获取到的DataSource和当前事务对应Connection的映射关系--当然这里Connection被包装为了ConnectionHolder。即Map的key是DataSource，value是当前数据库连接ConnectionHolder
  // 上面说的是Map的其中一个键值对。如果有的话，另外一对是DefaultSqlSessionFactory --> SqlSessionHolder
	private static final ThreadLocal<Map<Object, Object>> resources =
			new NamedThreadLocal<>("Transactional resources");
//事务监听者--在事务执行到某个阶段的过程中，会去回调监听者对应的回调接口(典型观察者模式的应用)---默认为空集合
	private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =
			new NamedThreadLocal<>("Transaction synchronizations");
//见名知意: 存放当前事务名字
	private static final ThreadLocal<String> currentTransactionName =
			new NamedThreadLocal<>("Current transaction name");
//见名知意: 存放当前事务是否是只读事务
	private static final ThreadLocal<Boolean> currentTransactionReadOnly =
			new NamedThreadLocal<>("Current transaction read-only status");
 //见名知意: 存放当前事务的隔离级别
	private static final ThreadLocal<Integer> currentTransactionIsolationLevel =
			new NamedThreadLocal<>("Current transaction isolation level");
//见名知意: 存放当前事务是否处于激活状态
	private static final ThreadLocal<Boolean> actualTransactionActive =
			new NamedThreadLocal<>("Actual transaction active");
    
    
     /**
	 * Unbind a resource for the given key from the current thread.
	 * @param key the key to unbind (usually the resource factory)
	 * @return the previously bound value (usually the active resource object)
	 * @throws IllegalStateException if there is no value bound to the thread
	 * @see ResourceTransactionManager#getResourceFactory()
	 */
	public static Object unbindResource(Object key) throws IllegalStateException {
		Object actualKey = TransactionSynchronizationUtils.unwrapResourceIfNecessary(key);        
         /*
         (1)第一个子线程回滚，从第一个子线程的TransactionStatus中获取到DataSource，
         然后从main线程的ThreadLocal中获取到map，
         map的key对应的数据源DataSource刚好和子线程的是一样的(因为使用同一个DruidDataSource)
         就可以从map中获取(main线程)关联的数据库连接，即value = (main线程)关联的数据库连接。map为空，然后移除map。
         value不为空，就不会抛出异常
         
         (2)执行到第二个子线程回滚，从第二个子线程的TransactionStatus中获取到DataSource，
          然后从main线程的ThreadLocal中获取到的map为null，然后获取到的value为null，就会抛出以下异常
          
          java.lang.IllegalStateException: No value for key [{
            CreateTime:"2024-04-07 17:46:11",
            ActiveCount:5,
            PoolingCount:1,
            CreateCount:6,
            DestroyCount:0,
            CloseCount:1,
            ConnectCount:6,
            Connections:[
                {ID:2046877342, ConnectTime:"2024-04-07 17:46:59", UseCount:1, LastActiveTime:"2024-04-07 18:07:48"}
            ]
        }] bound to thread
        
        （3）后续的子线程就不会执行回滚了
         */
		Object value = doUnbindResource(actualKey);
		if (value == null) {
			throw new IllegalStateException("No value for key [" + actualKey + "] bound to thread");
		}
		return value;
	}
    
    
    /**
	 * Actually remove the value of the resource that is bound for the given key.
	 */
	@Nullable
	private static Object doUnbindResource(Object actualKey) {
         // 从ThreadLocal中获取DataSource关联的数据库连接
		Map<Object, Object> map = resources.get();
		if (map == null) {
			return null;
		}
         // 获取到的数据库连接
		Object value = map.remove(actualKey);
		// Remove entire ThreadLocal if empty...
		if (map.isEmpty()) {
             // 如果map为空，移除ThreadLocal中的map，释放资源。
			resources.remove();
		}
		// Transparently suppress a ResourceHolder that was marked as void...
		if (value instanceof ResourceHolder && ((ResourceHolder) value).isVoid()) {
			value = null;
		}
		return value;
	}
}
```



总结：开启新事务的时候，每个线程的事务相关资源会存到相应线程的threadLocalMap中。在main线程的threadLocalMap中，获取不到子线程相关的事务资源，所以会抛出异常，回滚失败。

参考以下文章：[Spring在多线程环境下如何确保事务一致性-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2138148)



### 1.2 回滚成功

#### 1.2.1 线程之间传递事务属性



（1）创建多线程事务管理器，将子线程的事务属性copy到主线程

* 事务信息TcInfo

```java
@Data
public class TcInfo {
	
    private TransactionStatus transactionStatus;

    private MultiplyThreadTransactionManager.TransactionResource transactionResource;
}
```

* 多线程事务结果TcResult

```java
@Data
@Accessors(chain = true)
public class TcResult {
    //是否所有的Runable执行成功
    private boolean success;
    // 线程的事务信息
    private  List<TcInfo> threadTcInfos;
}
```

* 多线程事务管理器MultiplyThreadTransactionManager

```java
package com.mrlu.server.thread;

import lombok.Builder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.transaction.support.TransactionSynchronization;
import org.springframework.transaction.support.TransactionSynchronizationManager;

import javax.sql.DataSource;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * @author 简单de快乐
 * @create 2024-02-04 15:54
 *
 * @RequiredArgsConstructor会帮我们自动注入依赖
 * 多线程事务管理器
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class MultiplyThreadTransactionManager {


    public boolean execute(List<Runnable> tasks, Executor executor) {
        if(executor==null){
            throw new IllegalArgumentException("线程池不能为空");
        }
        //是否发生了异常
        AtomicBoolean ex = new AtomicBoolean();

        List<CompletableFuture> taskFutureList=new CopyOnWriteArrayList<>();
        List<TcInfo> tcInfos = new CopyOnWriteArrayList<>();
        tasks.forEach(task->{
            taskFutureList.add(CompletableFuture.runAsync(
                    () -> {
                        try{
                            //1.开启新事务
                            TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition);
                            //2.copy事务资源
                            TransactionResource transactionResource = TransactionResource.copyTransactionResource();

                            //3.设置事务属性等
                            TcInfo tcInfo = new TcInfo();
                            tcInfo.setTransactionStatus(transactionStatus);
                            tcInfo.setTransactionResource(transactionResource);
                            tcInfos.add(tcInfo);

                            //4.异步任务执行
                            task.run();
                        }catch (Throwable throwable){
                            //打印异常
                            throwable.printStackTrace();
                            //其中某个异步任务执行出现了异常,进行标记
                            ex.set(Boolean.TRUE);
                            //其他任务还没执行的不需要执行了
                            taskFutureList.forEach(completableFuture -> completableFuture.cancel(true));
                        }
                    }, executor)
            );
        });

        try {
            //阻塞直到所有任务全部执行结束---如果有任务被取消,这里会抛出异常滴,需要捕获
            CompletableFuture.allOf(taskFutureList.toArray(new CompletableFuture[]{})).get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        if (!ex.get()) {
            commit(tcInfos);
        } else {
            rollback(tcInfos);
        }
        return Boolean.TRUE;
    }

    /**
     * 在已经存在事务的线程中执行
     * @param tasks
     * @param executor
     * @return
     */
    public TcResult executeInExistingTc(List<Runnable> tasks, Executor executor) {
        if(executor==null){
            throw new IllegalArgumentException("线程池不能为空");
        }
        //是否发生了异常
        AtomicBoolean ex = new AtomicBoolean();

        List<CompletableFuture> taskFutureList = new CopyOnWriteArrayList<>();
        List<TcInfo> tcInfos = new CopyOnWriteArrayList<>();
        tasks.forEach(task->{
            taskFutureList.add(CompletableFuture.runAsync(
                    () -> {
                        try{
                            //1.开启新事务
                            TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition);
                            //2.copy事务资源
                            TransactionResource transactionResource = TransactionResource.copyTransactionResource();

                            //3.设置事务属性等
                            TcInfo tcInfo = new TcInfo();
                            tcInfo.setTransactionStatus(transactionStatus);
                            tcInfo.setTransactionResource(transactionResource);
                            tcInfos.add(tcInfo);

                            //4.异步任务执行
                            task.run();
                        } catch (Throwable throwable){
                            //打印异常
                            throwable.printStackTrace();
                            //其中某个异步任务执行出现了异常,进行标记
                            ex.set(Boolean.TRUE);
                            //其他任务还没执行的不需要执行了。后面的CompletableFuture.allOf会抛出ExecutionException
                            taskFutureList.forEach(completableFuture -> completableFuture.cancel(true));
                        }
                    }, executor)
            );
        });

        try {
            //阻塞直到所有任务全部执行结束---如果有任务被取消,这里会抛出异常滴,需要捕获
            CompletableFuture.allOf(taskFutureList.toArray(new CompletableFuture[]{})).get();
        } catch (InterruptedException | ExecutionException e) {
            log.error("thread exec error;", e);
            return new TcResult().setSuccess(false).setThreadTcInfos(tcInfos);
        }
        // 返回事务结果
        return new TcResult().setSuccess(!ex.get()).setThreadTcInfos(tcInfos);
    }

    public void commit(TransactionStatus existingTransactionStatus, List<TcInfo> threadTcInfos) {
        // 先提交调用者线程(即主线程)
        transactionManager.commit(existingTransactionStatus);
        // 再提交子线程
        commit(threadTcInfos);
    }

    public void rollback(TransactionStatus existingTransactionStatus, List<TcInfo> threadTcInfos) {
        // 先回滚调用者线程(即主线程)，释放主线程的事务属性。先回滚子线程的会报错的
        transactionManager.rollback(existingTransactionStatus);
        // 再回滚子线程
        rollback(threadTcInfos);
    }

    public void rollback(List<TcInfo> threadTcInfos) {
        process(threadTcInfos, false);
    }

    public void commit(List<TcInfo> threadTcInfos) {
        process(threadTcInfos, true);
    }

    private void  process(List<TcInfo> tcInfos, boolean commit) {
        for (TcInfo tcInfo : tcInfos) {
            TransactionResource transactionResource = tcInfo.getTransactionResource();
            TransactionStatus transactionStatus = tcInfo.getTransactionStatus();
            transactionResource.autoWiredTransactionResource();
            if (commit) {
                transactionManager.commit(transactionStatus);
            } else {
                transactionManager.rollback(transactionStatus);
            }
            transactionResource.removeTransactionResource();
        }
    }


    /**
     * 如果是多数据源的情况下,需要指定具体是哪一个数据源
     */
    private final DataSource dataSource;

    private final PlatformTransactionManager transactionManager;

    private final TransactionDefinition transactionDefinition;

    /**
     * 保存当前事务资源,用于线程间的事务资源COPY操作
     */
    @Builder
    public static class TransactionResource{
        //事务结束后默认会移除集合中的DataSource作为key关联的资源记录
        private  Map<Object, Object> resources;

        //下面五个属性会在事务结束后被自动清理,无需我们手动清理
        private  Set<TransactionSynchronization> synchronizations;

        private  String currentTransactionName;

        private Boolean currentTransactionReadOnly;

        private Integer currentTransactionIsolationLevel;

        private Boolean actualTransactionActive;

        public static TransactionResource copyTransactionResource(){
            return TransactionResource.builder()
                    //返回的是不可变集合
                    .resources(TransactionSynchronizationManager.getResourceMap())
                    //如果需要注册事务监听者,这里记得修改--我们这里不需要,就采用默认负责--spring事务内部默认也是这个值
                    .synchronizations(new LinkedHashSet<>())
                    .currentTransactionName(TransactionSynchronizationManager.getCurrentTransactionName())
                    .currentTransactionReadOnly(TransactionSynchronizationManager.isCurrentTransactionReadOnly())
                    .currentTransactionIsolationLevel(TransactionSynchronizationManager.getCurrentTransactionIsolationLevel())
                    .actualTransactionActive(TransactionSynchronizationManager.isActualTransactionActive())
                    .build();
        }

        public void autoWiredTransactionResource(){
            resources.forEach(TransactionSynchronizationManager::bindResource);
            //如果需要注册事务监听者,这里记得修改--我们这里不需要,就采用默认负责--spring事务内部默认也是这个值
            TransactionSynchronizationManager.initSynchronization();
            TransactionSynchronizationManager.setActualTransactionActive(actualTransactionActive);
            TransactionSynchronizationManager.setCurrentTransactionName(currentTransactionName);
            TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(currentTransactionIsolationLevel);
            TransactionSynchronizationManager.setCurrentTransactionReadOnly(currentTransactionReadOnly);
        }


        public void removeTransactionResource() {
            //事务结束后默认会移除集合中的DataSource作为key关联的资源记录
            //DataSource如果重复移除,unbindResource时会因为不存在此key关联的事务资源而报错
            resources.keySet().forEach(key->{
                if(!(key instanceof DataSource)){
                    TransactionSynchronizationManager.unbindResource(key);
                }
            });
        }
    }


    /**================================以下实现也可以=================================================*/
    /**
     * 执行的是无返回值的任务
     * @param tasks 异步执行的任务列表
     * @param executor 异步执行任务需要用到的线程池,考虑到线程池需要隔离,这里强制要求传
     */
    public void runAsyncButWaitUntilAllDown(List<Runnable> tasks, Executor executor) {
        if(executor==null){
            throw new IllegalArgumentException("线程池不能为空");
        }
        DataSourceTransactionManager transactionManager = getTransactionManager();
        //是否发生了异常
        AtomicBoolean ex=new AtomicBoolean();

        List<CompletableFuture> taskFutureList=new CopyOnWriteArrayList<>();
        List<TransactionStatus> transactionStatusList=new CopyOnWriteArrayList<>();
        List<TransactionResource> transactionResources=new CopyOnWriteArrayList<>();

        tasks.forEach(task->{
            taskFutureList.add(CompletableFuture.runAsync(
                    () -> {
                        try{
                            //1.开启新事务
                            transactionStatusList.add(openNewTransaction(transactionManager));
                            //2.copy事务资源
                            transactionResources.add(TransactionResource.copyTransactionResource());
                            //3.异步任务执行
                            task.run();
                        }catch (Throwable throwable){
                            //打印异常
                            throwable.printStackTrace();
                            //其中某个异步任务执行出现了异常,进行标记
                            ex.set(Boolean.TRUE);
                            //其他任务还没执行的不需要执行了
                            taskFutureList.forEach(completableFuture -> completableFuture.cancel(true));
                        }
                    }
                    , executor)
            );
        });

        try {
            //阻塞直到所有任务全部执行结束---如果有任务被取消,这里会抛出异常滴,需要捕获
            CompletableFuture.allOf(taskFutureList.toArray(new CompletableFuture[]{})).get();
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        //发生了异常则进行回滚操作,否则提交
        if(ex.get()){
            log.info("发生异常,全部事务回滚");
            for (int i = 0; i < tasks.size(); i++) {
                transactionResources.get(i).autoWiredTransactionResource();
                transactionManager.rollback(transactionStatusList.get(i));
                transactionResources.get(i).removeTransactionResource();
            }
        }else {
            log.info("全部事务正常提交");
            for (int i = 0; i < tasks.size(); i++) {
                transactionResources.get(i).autoWiredTransactionResource();
                transactionManager.commit(transactionStatusList.get(i));
                transactionResources.get(i).removeTransactionResource();
            }
        }
    }

    private TransactionStatus openNewTransaction(DataSourceTransactionManager transactionManager) {
        //JdbcTransactionManager根据TransactionDefinition信息来进行一些连接属性的设置
        //包括隔离级别和传播行为等
        DefaultTransactionDefinition transactionDef = new DefaultTransactionDefinition();
        //开启一个新事务---此时autocommit已经被设置为了false,并且当前没有事务,这里创建的是一个新事务
        return transactionManager.getTransaction(transactionDef);
    }

    private DataSourceTransactionManager getTransactionManager() {
        return new DataSourceTransactionManager(dataSource);
    }
    /**================================以上实现也可以=================================================*/
}
```



```java
@Service
@Slf4j
public class MultiThreadTcService {
 	@Autowired
    private PersonService personService;    
    @Autowired
    private AnimalService animalService;   
    
    
    /**
     * 多线程事务回滚成功情况一
     * 主线程无事务操作，所有的事务操作都在子线程中
     */
    public Boolean batchTcRollBackSuccess01() {
        List<Runnable> tasks = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            int finalI = i;
            Thread task = new Thread(() -> {
                // 业务逻辑
                animalService.save(new Animal().setName(UUID.randomUUID().toString()));
                // 模拟异常
                if (finalI == 3) {
                    int a = 1 / 0;
                }
            });
            tasks.add(task);
        }
        return multiplyThreadTransactionManager.execute(tasks, threadPoolExecutor);
    }

    /**
     * 多线程事务回滚成功情况二
     * 主线程有事务操作(编程式事务)，所有的事务操作都在子线程中
     */
    public Boolean batchTcRollBackSuccess02() {
        // 主线程开启编程式事务
        TransactionStatus transactionStatus = platformTransactionManager.getTransaction(transactionDefinition);
        Person school = new Person().setName("main02-" + UUID.randomUUID());
        personService.save(school);

        // 开启多线程执行其他业务逻辑
        List<Runnable> tasks = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            int finalI = i;
            Thread task = new Thread(() -> {
                // 业务逻辑
                animalService.save(new Animal().setName(UUID.randomUUID().toString()));
                // 模拟异常
                if (finalI == 3) {
                    int a = 1 / 0;
                }
            });
            tasks.add(task);
        }

        TcResult tcResult = multiplyThreadTransactionManager.executeInExistingTc(tasks, threadPoolExecutor);
        boolean commit = tcResult.isSuccess();
        if (commit) {
            multiplyThreadTransactionManager.commit(transactionStatus, tcResult.getThreadTcInfos());
        } else {
            multiplyThreadTransactionManager.rollback(transactionStatus, tcResult.getThreadTcInfos());
        }
        return Boolean.TRUE;
    }
   
}
```

参考以下文章：[Spring在多线程环境下如何确保事务一致性-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2138148)



#### 1.2.2 使用同一个数据库连接

##### 1.2.2.1 没有使用同一个数据库连接的情况

```java
@Service
@Slf4j
public class MultiThreadTcService {
 	@Autowired
    private PersonService personService;    
    @Autowired
    private AnimalService animalService;   
    
    
    @Autowired
    private SqlSessionFactory sqlSessionFactory;

    public SqlSession getSqlSession(){
        //DefaultSqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        return sqlSession;
    }

    //spring自动注入的mapper
    @Autowired
    private AnimalMapper animalMapper;

    @Autowired
    private PersonMapper personMapper;

    /**
     * 没有使用同一个数据库连接，回滚失败
     */
    public void threadRollBackFailed04() throws SQLException {
        AtomicBoolean execResult = new AtomicBoolean(true);
        SqlSession sqlSession = getSqlSession();
        Connection connection = sqlSession.getConnection();
        try {
            connection.setAutoCommit(false);
            CountDownLatch downLatch = new CountDownLatch(5);
            
            Person school = new Person().setName("main03-" + UUID.randomUUID());
            personMapper.insert(school);

            List<String> names = new CopyOnWriteArrayList<>();
            for (int i = 0; i < 5; i++) {
                int finalI = i;
                new Thread(() -> {
                    boolean flag = execResult.get();
                    if (!flag) {
                        return;
                    }
                    try {
                        String name = "main03-sub-" + UUID.randomUUID().toString();
                        names.add(name);
                        Animal animal = new Animal().setName(name);

                        // MybatisMapperProxy
                        int insert = animalMapper.insert(animal);
                        if (finalI == 3) {
                            int a = 1/0;
                        }
                    } catch (Exception e) {
                        execResult.compareAndSet(true, false);
                        throw new ServiceException(e);
                    } finally {
                        downLatch.countDown();
                    }
                }).start();
            }
            downLatch.await();
            List<Animal> animals = animalMapper.selectList(new LambdaQueryWrapper<Animal>().in(Animal::getName, names));
            log.info("animals={}", animals);

            // 获取所有线程的最终执行结果来确定事务是否需要回滚
            boolean finalResult = execResult.get();
            if (finalResult) {
                connection.commit();
            } else {
                connection.rollback();
            }
            log.info("=============finish===============");
        } catch (Exception e) {
            e.printStackTrace();
            connection.rollback();
        }
    }
    
    
}
```



* 分析

为什么没有执行回滚了，db还有执行结果呢？？？

答：没有使用同一个数据库连接导致。主线程数据库连接对应的事务和子线程数据库连接对应的事务是不一样的，即使主线程事务回滚了，子线程的事务也不会回滚。见以下说明

```
（1）Connection connection = sqlSession.getConnection();
获取数据库连接，然后根据这个数据库连接回滚事务。

（2）spring使用SqlSessionTemplate创建mapper的代理类，底层是用SqlSessionTemplate来执行sql的。SqlSessionTemplate会给每个线程创建一个新的DefaultSqlSession（如果当前线程的threadLocal中不存在的话），然后用DefaultSqlSession获取数据库连接，即spring创建的mapper在每个线程中执行sql，都会使用一个新的数据库连接。
```

所以子线程和主线程并不都是使用同一个connection来操作。

参考[Mybatis(二)SqlSession之线程安全 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/343374447)



##### 1.2.2.2 使用同一个数据库连接的情况

```java
@Service
@Slf4j
public class MultiThreadTcService {
 	@Autowired
    private PersonService personService;    
    @Autowired
    private AnimalService animalService;   
    
    @Autowired
    private SqlSessionFactory sqlSessionFactory;

    public SqlSession getSqlSession(){
        //DefaultSqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        return sqlSession;
    }

    // Spring自动注入SqlSessionTemplate
    @Autowired
    private SqlSession sqlSessionBySpring;
    
    //Spring自动注入的mapper
    @Autowired
    private AnimalMapper animalMapper;

    @Autowired
    private PersonMapper personMapper;


    public void batchTcRollBackSuccess03() throws SQLException {
        AtomicBoolean execResult = new AtomicBoolean(true);
        SqlSession sqlSession = getSqlSession();
        Connection connection = sqlSession.getConnection();
        try {
            connection.setAutoCommit(false);
            CountDownLatch downLatch = new CountDownLatch(5);
            /*
             * 1、不使用自动注入的mapper。因为在mapper执行sql的过程中，底层使用的SqlSessionTemplate
             * 2、不使用自动注入的sqlSessionBySpring来生成mapper。因为自动注入的sqlSession是SqlSessionTemplate，
             *    在mapper执行sql的过程中，SqlSessionTemplate会给每个线程创建一个新的DefaultSqlSession（如果当前线程不存在的话），
             *    然后用DefaultSqlSession获取数据库连接，即自动注入的SqlSessionTemplate会给每个线程创建一个数据库连接。
             *
             * 要怎么做才能使用同一个数据库连接呢？？？
             * 答：我们发现创建数据库连接使用的是DefaultSqlSession，因此我们通过SqlSessionFactory来创建DefaultSqlSession。
             * 然后根据DefaultSqlSession获取数据库连接，从而保证数据库连接已经存到DefaultSqlSession中。
             * 最后根据DefaultSqlSession创建Mapper，就实现创建的Mapper使用同一个DefaultSqlSession，
             * 从而达到使用DefaultSqlSession里的(同一个)数据库连接。
             *
             *
             * 需要注意的是: 我们要先在main线程中获取数据库连接，再获取Mapper，这个顺序是不能变的。
             * 为什么呢？？
             * 答：假设有5个子线程，我们先获取Mapper，然后在子线程中执行逻辑和在主线程中获取数据库连接。
             * 这样子线程有可能先获取到数据库连接a，设置DefaultSqlSession中的数据库连接为a，主线程执行慢，得到数据库连接b，
             * 就会重新设置DefaultSqlSession中的数据库连接为b。
             * 子线程使用覆盖前的数据库连接a继续执行逻辑，主线程使用数据库连接b执行，这两个线程使用的不是同一个连接。
             *
             */
            AnimalMapper animalMapperBySession = sqlSession.getMapper(AnimalMapper.class);
            PersonMapper personMapperBySession = sqlSession.getMapper(PersonMapper.class);

            Person school = new Person().setName("main03-" + UUID.randomUUID());
            personMapperBySession.insert(school);
            List<String> names = new CopyOnWriteArrayList<>();

            for (int i = 0; i < 5; i++) {
                int finalI = i;
                new Thread(() -> {
                    boolean flag = execResult.get();
                    if (!flag) {
                        return;
                    }
                    try {
                        String name = "main03-sub-" + UUID.randomUUID().toString();
                        names.add(name);
                        Animal animal = new Animal().setName(name);
                        int insert = animalMapperBySession.insert(animal);


                        if (finalI == 3) {
                            int a = 1/0;
                        }

                        // MybatisMapperProxy
                        // 这里底层用的是spring自动注入的mapper，不会回滚
                        // animalService.save4Tc(finalI);
                    } catch (Exception e) {
                        execResult.compareAndSet(true, false);
                        throw new ServiceException(e);
                    } finally {
                        downLatch.countDown();
                    }
                }).start();
            }

            downLatch.await();
            List<Animal> animals = animalMapperBySession.selectList(new LambdaQueryWrapper<Animal>().in(Animal::getName, names));
            log.info("animals={}", animals);

            // 获取所有线程的最终执行结果来确定事务是否需要回滚
            boolean finalResult = execResult.get();
            if (finalResult) {
                connection.commit();
            } else {
                connection.rollback();
            }
            log.info("=============finish===============");
        } catch (Exception e) {
            e.printStackTrace();
            connection.rollback();
        }
    }      
    
    
}
```





* 分析

1、Spring创建Mapper执行SQL过程

大概流程

```
Mapper --> MybatisMapperProxy --> 保存各自的SqlSession(SqlSessionTemplate) --> 使用sqlSession来执行sql，这里是sqlSession代理类SqlSessionInterceptor --> 代理类SqlSessionInterceptor来执行sql -->  
SqlSessionInterceptor中每个线程重新获取SqlSession来执行sql，获取到的SqlSession=DefaultSqlSession（不会自动提交事务SpringManagedTransaction）

--> DefaultSqlSession中的Executor=SimpleExecutor执行sql （sql的信息保存在MappedStatement）
--> SimpleExecutor生成StatementHandler（包含PreparedStatementHandler），获取数据库连接Connection 
--> StatementHandler使用Connection预编译好sql，得到PreparedStatement，然后使用PreparedStatementHandler给sql注入参数 
--> PreparedStatement执行sql
```



详细流程

（1）创建Mapper

```
Mapper --> MapperFactoryBean --> SqlSessionTemplate --> MybatisMapperProxyFactory --> MybatisMapperProxy
```

总结：Spring通过MapperFactoryBean将Mapper接口包装成Spring Bean，并在背后通过Mybatis的MybatisMapperProxyFactory生成一个代理对象MybatisMapperProxy，该代理对象在执行方法时通过SqlSessionTemplate调用数据库。



（2）Mapper执行SQL

```
以下是对MyBatis执行SQL的流程进行优化和简化后的描述：

1. MybatisMapperProxy接收到SQL请求，根据SQL类型，SqlSessionTemplate选择相应的执行逻辑。
2. SqlSessionTemplate通过代理类SqlSessionInterceptor执行SQL操作。
3. SqlSessionInterceptor从ThreadLocal获取SqlSession，如果获取不到，则创建DefaultSqlSession。
4. DefaultSqlSession执行SQL操作，根据执行的SQL信息创建MappedStatement。
5. SimpleExecutor根据MappedStatement创建RoutingStatementHandler
6. SimpleExecutor使用SpringManagedTranaction和DataSource获取数据库连接Connection。
7. RoutingStatementHandler使用PreparedStatementHandler和Connection初始化SQL，预编译SQL语句。
8. PreparedStatementHandler使用MybatisParameterHandler给PreparedStatement设置SQL参数。
9. 执行PreparedStatement，返回结果。

在创建DefaultSqlSession时，会进行以下操作：
1. 创建SpringManagedTranaction。
2. 创建SimpleExecutor，并将SpringManagedTranaction设置到SimpleExecutor。
3. 设置自动提交事务autoCommit=false。

在创建RoutingStatementHandler时，会进行以下操作：
1.根据MappedStatement类型选择要创建的StatementHandler类型
	一般的写操作会选择PreparedStatementHandler，查询操作会选择SimpleStatementHandler
2.根据MappedStatement，sql参数，SimpleExecutor等创建StatementHandler，指定给delegate属性。


类流向：
MybatisMapperProxy --> MybatisMapperMethod --> SqlSessionTemplate --> SqlSessionInterceptor 
--> DefaultSqlSession --> SimpleExecutor --> PreparedStatementHandler与Connection --> PreparedStatement 
```





2、自己创建的DefaultSqlSession获取数据库连接和创建Mapper

* 通过DefaultSqlSession获取的mapper

```
Mapper --> MybatisMapperProxy --> DefaultSqlSession执行sql --> 
--> DefaultSqlSession中的Executor=SimpleExecutor执行sql （sql的信息保存在MappedStatement）
--> SimpleExecutor生成StatementHandler（包含PreparedStatementHandler），获取数据库连接Connection 
--> StatementHandler使用Connection预编译好sql，得到PreparedStatement，然后使用PreparedStatementHandler给sql注入参数 
--> PreparedStatement执行sql
```

1、使用DefaultSqlSession获取数据库连接Connection。

2、通过DefaultSqlSession获取的mapper，这些mapper都会使用这个DefaultSqlSession（即使这些mapper在不同的线程中使用）。

3、使用DefaultSqlSession的Connection来执行sql。Connection不存在的时候先创建，创建了就不重复创建。**所以先要在主线程中获取数据库连接，避免在子线程中重复创建。**



##### 1.2.3 每个线程各自的数据库连接和Mapper，统一回滚

```java
@Service
@Slf4j
public class MultiThreadTcService {
	@Autowired
    private SqlSessionFactory sqlSessionFactory;

    public SqlSession getSqlSession(){
        //DefaultSqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();
        return sqlSession;
    }

    
    public void batchTcRollBackSuccess04() throws SQLException {
        List<Connection> connections = new CopyOnWriteArrayList<>();
        AtomicBoolean execResult = new AtomicBoolean(true);
        SqlSession mainSqlSession = getSqlSession();
        Connection mainConnection = mainSqlSession.getConnection();
        try {
            /*
             * 1、main线程获取sqlSession，使用sqlSession获取main线程的数据库连接，即mainConnection。
             * 通过mainConnection获取Mapper，获取到的Mapper在底层会使用mainConnection操作数据库。
             *
             * 2、每个子线程获取各自的sqlSession，使用sqlSession获取各自的数据库连接，
             * 再通过数据库连接获取Mapper，最终每个线程里的Mapper都会使用各自的数据库连接操作数据库。
             *
             * 3、统一收集子线程的执行结果，如果子线程和main都执行成功，就提交所有数据库连接对应的事务。反正，则回滚。
             */
            mainConnection.setAutoCommit(false);
            connections.add(mainConnection);
            CountDownLatch downLatch = new CountDownLatch(5);
            AnimalMapper animalMapperBySession = mainSqlSession.getMapper(AnimalMapper.class);
            PersonMapper personMapperBySession = mainSqlSession.getMapper(PersonMapper.class);
            Person school = new Person().setName("main04-" + UUID.randomUUID());
            personMapperBySession.insert(school);

            List<String> names = new CopyOnWriteArrayList<>();
            for (int i = 0; i < 5; i++) {
                int finalI = i;
                new Thread(() -> {
                    boolean flag = execResult.get();
                    if (!flag) {
                        return;
                    }
                    try {
                        SqlSession subThreadSqlSession = getSqlSession();
                        Connection subThreadConnection = subThreadSqlSession.getConnection();
                        subThreadConnection.setAutoCommit(false);
                        AnimalMapper animalMapperBySubThread = subThreadSqlSession.getMapper(AnimalMapper.class);
                        connections.add(subThreadConnection);

                        String name = "main04-sub-" + UUID.randomUUID().toString();
                        names.add(name);
                        Animal animal = new Animal().setName(name);
                        animalMapperBySubThread.insert(animal);

                        if (finalI == 3) {
                            int a = 1/0;
                        }
                    } catch (Exception e) {
                        execResult.compareAndSet(true, false);
                        log.info("子线程发生异常,", e);
                    } finally {
                        downLatch.countDown();
                    }
                }).start();
            }

            downLatch.await();
            // 这里子事务还没有提交，主线程的数据库连接是查不到的
            List<Animal> animals = animalMapperBySession.selectList(new LambdaQueryWrapper<Animal>().in(Animal::getName, names));
            log.info("animals={}", animals);

            // 获取所有线程的最终执行结果来确定事务是否需要回滚
            commitOrRollback(execResult.get(), connections);
        } catch (Exception e) {
            commitOrRollback(false, connections);
            e.printStackTrace();
        } finally {
            close(connections);
        }
    }

    private void commitOrRollback(boolean commit, List<Connection> connections) throws SQLException {
        for (Connection connection : connections) {
            if (commit) {
                connection.commit();
            } else {
                connection.rollback();
            }
        }
        log.info("finish commitOrRollback;commit={}", commit);
    }

    private void close(List<Connection> connections) throws SQLException {
        for (Connection connection : connections) {
            connection.close();
        }
    }

}
```

